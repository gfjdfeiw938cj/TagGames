<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: sans-serif;
  font-size: 40px;
  width: 100%;
  min-height: 100vh;
}

[class^="box-"] {
  background-color: skyblue;
  display: grid;
  place-items: center;
  border: 1px solid #000;;
} 

.div_container {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  height: 100vh;
}

.container {
  display: grid;
  height: 450px; 
  width: 450px;
  grid-auto-columns: 1fr; /*автоматически определяем размер тех столбцов которые не были указанны явно*/
  grid-auto-rows: 1fr; 
  justify-content: center;
  align-content : center;
}  

[data-emptyСell = "false"]{
  background-color: rgb(101, 145, 32);
}

.ziro{
  background-color: #000
}

.hidden {
  display: none;  /* Делает элемент невидимым*/
}
                                /* Стилизация модального окна */
#modal {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
}

#modal__window {
  position: relative;
  top: 30%;
  width: 30%;
  margin: 0 auto;
  padding: 5px 20px 20px;
  background-color: #f8f6f6;
  text-align: center;
}

button {
  min-width: 100px;
  border: 1px solid lightgray;
  padding: 15px;
  background-color: #fff;
  font-size: 20pt;
  border-radius: 15px;
  opacity: 0.7;
}
                                      /* отсчёт времени и ходов  */
.container_сountdown_progress {
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 38px;
}

.couterGame{
  margin-right: 20px;
}

                                    /* Кнопка начать с начала  */

.reset {
  font-size: 36px;
  height: 65px;
  text-align: center;
  background-color: #658597;
  cursor: pointer;
  border: none;
  box-shadow: 1px 1px 7px 1px rgba(0, 0, 0, 0.65);
  margin: 0 auto;
}

.resetVictory {
  font-size: 36px;
  height: 65px;
  text-align: center;
  background-color: #207e18;
  cursor: pointer;
  border: none;
  box-shadow: 1px 1px 7px 1px rgba(69, 102, 76, 0.65);
  margin: 0 auto;
}

.panel {
  margin-top: 20px;
}
    </style>
</head>
<body>
<!-- ---------------------------------------------------------- -->
 <!-- <div class="box-1"> 2 </div>
  <div class="box-1"> 1 </div>
  <div class="box-1"> 3 </div>
  <div class="box-1"> 4 </div>
  <div class="box-2"> 5 </div>
  <div class="box-2 ziro"></div>
  <div class="box-2"> 6 </div>
  <div class="box-2"> 7 </div>
  <div class="box-3"> 8 </div>
  <div class="box-3"> 9 </div>
  <div class="box-3"> 10 </div>
  <div class="box-3"> 11 </div>
  <div class="box-4"> 12 </div>
  <div class="box-4"> 13 </div>
  <div class="box-4"> 14 </div>
  <div class="box-4"> 15 </div> -->


                                           <!-- Алгоритм для определения решаемости позиции:
Посчитать количество инверсий.
Посмотреть на ширину пазла. Если ширина нечётная и число инверсий чётное, то позиция решаемая, иначе — нерешаемая.
Если ширина чётная, найти номер строки пустой клетки, считая снизу.
Посмотреть на число инверсий. Если число инверсий чётное и номер строки пустой клетки нечётный,
то позиция решаемая, иначе — нерешаемая.
Если число инверсий нечётное и номер строки пустой клетки чётный, то позиция решаемая, иначе — нерешаемая. -->
<!-- ---------------------------------------------------------- -->

<div class="div_container">
  <div class="container_сountdown_progress">
    <div class="couterGame"></div>
    <div class="time_display" id="display">00:00</div>
  </div>
  <div class="container"></div>
  <div class="panel">
    <button class="reset">С начала</button>
</div>

</div>

<div id="modal" class="hidden">
  <div id="modal__window">
    <h2>Победа</h2>
      <div id="modal__buttons">
        <button class="resetVictory">Играть еще</button>
      </div>
  </div>
</div>

<script>
  
let timer = document.getElementById('display');
let containerBord = document.querySelector('.container')
let модальное_окно = document.querySelector('.hidden')
let start_New_Game_Btn = document.querySelector('.reset')
let start_New_Game_Btn_Victory = document.querySelector('.resetVictory')
let couterGameElemen = document.querySelector('.couterGame')

let matrixRandomCells 
let couterGame = 0
let seconds = 0;
let minutes = 0;
let шаблонМатрицы
let timerId
// let CloneArrMatrix = arr

window.addEventListener('load', startGame);

function renderMap(matrixArr, couter){
  matrixArr.forEach((el, indСoordinate_Y) => {
    el.forEach((number, indСoordinate_X) => {
      let div = document.createElement('div');
      let arrAtributsValue = [
        ["data-x", `${indСoordinate_X}`],
        ["data-y", `${indСoordinate_Y}`], 
        ["class", `${number === '' ? 'ziro':`box-${indСoordinate_Y}`}`], 
        ['data-emptyСell', `${number === шаблонМатрицы[indСoordinate_Y][indСoordinate_X] ? false: true}`]
      ]
      arrAtributsValue.forEach( el => div.setAttribute(el[0], el[1]))
        // div.setAttribute("class", "box-1");
      div.innerHTML = number;
      containerBord.append(div)
    })
  })
  couterGameElemen.innerHTML = `Xодов: ${couter}`
}

// renderMap(arr, 0) 

containerBord.addEventListener('click', function (event) {
  if(event.target.innerHTML === '') return
  couterGame++
  // console.log(event.target.innerHTML)
  logic(event.target.dataset)
  // determinantGameConditions(event.target.dataset)
  removeCellBord()
  renderMap(matrixRandomCells, couterGame)
});
 

start_New_Game_Btn.addEventListener('click', function (event) {
  removeCellBord()
  startGame() 
  модальное_окно.classList.add('hidden')
})

start_New_Game_Btn_Victory.addEventListener('click', function() {
  removeCellBord()
  startGame() 
  модальное_окно.classList.add('hidden')
 })

function startGame(){
  let matrixSizeHigth, matrixSizeWidth
  if(timerId) clearTimeout(timerId)
  while(!(Number.isInteger(matrixSizeHigth) && (matrixSizeHigth >= 3 && matrixSizeHigth <= 6))) {
    matrixSizeHigth = Number(prompt("Введите длинну игрового поля (от 3 до 6)", ''));
  }
  while(!(Number.isInteger(matrixSizeWidth) && (matrixSizeWidth >= 3 && matrixSizeWidth <= 6))) {
    matrixSizeWidth = Number(prompt("Введите ширину игрового поля (от 3 до 6)", ''));
  }
  matrixRandomCells = createMatrix(matrixSizeHigth, matrixSizeWidth)
  timerId = setInterval(incrementTime, 1000)
  renderMap(matrixRandomCells, 0) 
}

 // Функция обновления времени
  function updateDisplay() {
    let formattedSeconds = seconds.toString().padStart(2, '0');
    let formattedMinutes = minutes.toString().padStart(2, '0');
    timer.textContent = `Время: ${formattedMinutes}:${formattedSeconds}`;
  }

// Функция увеличения времени на 1 секунду
  function incrementTime() {
    seconds++;
    if(seconds >= 60) {
      seconds = 0;
      minutes++;
    }
    updateDisplay();
  }

function logic({x, y, emptyСell}){
  x = Number(x); y = Number(y);
 
  let arrГоризонталь =  matrixRandomCells[y];

  let arrВертикаль = matrixRandomCells.map(el => el[x]);
  // вертикаль.includes("")

  let BooleanГоризонталь = arrГоризонталь.some((el) => el === "")
  let BooleanВертикаль = arrВертикаль.some((el) => el === "")
  let новаяГоризонталь 

  if(BooleanГоризонталь){
    let indEmptyСell = arrГоризонталь.indexOf('')
    if(indEmptyСell > x){
      новаяГоризонталь = arrГоризонталь.copyWithin(indEmptyСell - (indEmptyСell - x - 1) , x, indEmptyСell).toSpliced(x, 1, '')
    } else {
      новаяГоризонталь = arrГоризонталь.copyWithin(indEmptyСell , indEmptyСell + 1 , x + 1 ).toSpliced(x, 1, '')
    }
    matrixRandomCells[y] = новаяГоризонталь
    determinantGameConditions(новаяГоризонталь, y)
    return 
  }else if(BooleanВертикаль){
    let indEmptyСell = arrВертикаль.indexOf('')
    if(indEmptyСell > y){
      новаяГоризонталь = arrВертикаль.copyWithin(indEmptyСell - (indEmptyСell - y - 1) , y, indEmptyСell).toSpliced(y, 1, '')
    } else {
      новаяГоризонталь = arrВертикаль.copyWithin(indEmptyСell , indEmptyСell + 1 , y + 1 ).toSpliced(y, 1, '')
    }
    determinantGameConditions(новаяГоризонталь, y)
    matrixRandomCells.forEach((el, ind) =>  el[x] = новаяГоризонталь[ind])
    return 
  }else{
    return
  }
}

function createMatrix(height, width){
// let arr = [
//   [1,  2,  3],
//   [4,  5,  6],
//   [7, '', 8],
//   ]

  let maxIndexArrMatrix = height * width;
  let i = 1
  шаблонМатрицы = Array.from({ length: height }, () => Array.from({ length: width }, () => i === maxIndexArrMatrix ? '': i++));
  matrixRandomCells = randomNumberMatrix(maxIndexArrMatrix, Math.floor(Math.random() * maxIndexArrMatrix), шаблонМатрицы, i, height, width)
  let matrixClassPattern = шаблонМатрицы.map( el => `"${el.map( el => el = 'A').join(" ")}"`);
  containerBord.style.gridTemplateAreas = matrixClassPattern.join('')
  // console.log(isSolvable(matrixRandomCells.flat(), matrixRandomCells.length, matrixRandomCells[0].length)) 
  return matrixRandomCells // arr
}
//-----------------------------------------------------------------------------------------------------------------

function randomNumberMatrix(maxIndexArrMatrix, indEmptyСell, шаблонМатрицы, i, height, width){
  i = 0
  let numbers = new Set();
  let j = 0
  while (numbers.size < maxIndexArrMatrix - 1) {
    let randomNumber = Math.floor(Math.random() * (maxIndexArrMatrix - 1)) + 1;
    numbers.add(randomNumber);
  }
  numbers = Array.from(numbers)
  let defaultedMatrix = checkingSolvable(numbers, indEmptyСell, height, width)
  return Array.from({ length: height }, () => Array.from({ length: width }, () => defaultedMatrix[i++] ))
}


function removeCellBord(){
  containerBord.innerHTML = '';
  // Второй вариант
  // while (containerBord.firstChild) {
  //   containerBord.firstChild.remove();
  // }
}

function determinantGameConditions(arrОсь, indОсьY){
  
  // let шаблонМатрицы = [
  //   [1,  2,  3,  4,   5],
  //   [6,  7,  8,  9,  10],
  //   [11, 12, 13, 14, 15],
  //   [16, 17, 18, 19, ''],
  // ]

let matrixDeterminant =  matrixRandomCells.every((el, indОсьX) => el.toString() === шаблонМатрицы[indОсьX].toString())  
  if(matrixDeterminant){
    модальное_окно.classList.remove('hidden');
  }
}

function checkingSolvable(puzzle, indEmptyСell, heightMatrix, widthMatrix){
    let twoNumbersInversion
    function countInversions(arr){
      if (arr.length <= 1) return 0;
        
      const mid = Math.floor(arr.length / 2);
      const left = arr.slice(0, mid);
      const right = arr.slice(mid);
        
      let inversions = countInversions(left) + countInversions(right);
        
      let i = 0, j = 0, k = 0;
      while(i < left.length && j < right.length){
        if (left[i] <= right[j]) {
          arr[k++] = left[i++];
        }else{
          arr[k++] = right[j++];
          if(!twoNumbersInversion && right.length > 1 && left.length > 1){
            twoNumbersInversion = [right[0], left[1]];
          } 
          inversions += left.length - i; // все оставшиеся в left > right[j]
        }
      }
      while (i < left.length) arr[k++] = left[i++];
      while (j < right.length) arr[k++] = right[j++];
        
      return inversions;
    }
    
    const inversions = countInversions(puzzle.slice());
    if (widthMatrix % 2 === 1){
      if(inversions % 2 === 0){
        puzzle.splice(indEmptyСell, 0, '');
        return puzzle;
      } else {
        puzzle[puzzle.indexOf(twoNumbersInversion[1])] = twoNumbersInversion[0];
        puzzle[puzzle.lastIndexOf(twoNumbersInversion[0])] = twoNumbersInversion[1];
        puzzle.splice(indEmptyСell, 0, '');
        return puzzle;
      }
      return 
    }else{
      let heightEmptyСell = heightMatrix - Math.floor(indEmptyСell / widthMatrix) // Высота пустой клетки. Отсчет идет начиная с 1 и с низу в верх 
      const inversionsEven = inversions % 2 === 0;
      const zeroRowOdd = heightEmptyСell % 2 === 1;
        if(inversionsEven === zeroRowOdd){
          puzzle.splice(indEmptyСell, 0, '')
          return puzzle
        }else if(zeroRowOdd === false){ //нечетная строка
          if(puzzle.length - heightEmptyСell === 0) puzzle.splice(indEmptyСell + widthMatrix, 0, '');
          else puzzle.splice(indEmptyСell - widthMatrix, 0, '');
            return puzzle
        }else { //четная строка
          if(heightEmptyСell === 1) puzzle.splice(indEmptyСell - widthMatrix, 0, '');
          puzzle.splice(indEmptyСell + widthMatrix, 0, '');
          return puzzle
        } 
    }
}

    </script>
</body>
</html>